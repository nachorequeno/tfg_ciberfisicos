%\chapter{Introducción histórica}
%
%\section{Antecedentes históricos y actualidad (español)}
%Primera sección.
%
%\section{Historical and current background (English)}
%
%\begin{otherlanguage}{british}
%En inglés
%\end{otherlanguage}

\chapter{Introducción}

\section{Sistemas ciberfísicos}
Los sistemas ciberfísicos son un tipo especial de sistemas en tiempo real que combinan un micro controlador o programa software, representado mediante una máquina de estados discretos, con uno o varios sensores que interactúan sobre una variable física. Ejemplos de este tipo de entornos son los ordenadores de a bordo que regulan la velocidad de crucero de un vehículo, o el piloto automático que controla la altitud y trayectoria de un avión.

Garantizar el correcto funcionamiento de estas plataformas es crucial, ya que un mal funcionamiento conlleva una reducción del comfort por parte de los usuario o, incluso, la pérdida de vidas humanas. Una manera de asegurarlo es mediante el uso de técnicas de verificación formal. Las técnicas de verificación en tiempo de ejecución \cite{STTT_RV_21} (\emph{runtime verification} en inglés) implementan un monitor que supervisa que la ejecución actual cumple con los requisitos especificados. Los monitores actúan como guardianes, alertando al usuario cuando la ejecución se desvía del comportamiento deseado e, incluso, implementando contramedidas para revertir ese hecho y redirigir el sistema hacia un estado saludable. 

Existen diversos formalismos para definir los comportamientos deseados y no deseados. Los requisitos funcionales se pueden expresar operacionalmente, mediante algún tipo de autómata de estados finito, o declarativamente, mediante una descripción lógico-matemática. Dentro de esta segunda categoría, la lógica temporal es un tipo de lógica modal que expresa propiedades sobre un \emph{estado} en particular del sistema, o sobre los \emph{caminos} (es decir, secuencia de estados) que atraviesa. En este trabajo utilizaremos Signal Temporal Logic \cite{STL}, un tipo de lógica temporal enfocada al análisis de señales analógicas.

\section{Objetivos}

Los objetivos de este proyecto son:

\begin{itemize}
\item Extender las capacidades de la lógica temporal para expresar propiedades que involucren \textit{tendencias} (derivadas), o \textit{acumulaciones} (integrales), mediante el cálculo de éstas nuevas operaciones podemos realizar operaciones de predicción a futuro en base a unas señales ya conocidas y recogidas del artefacto que querramos monitorizar.   
\item Implementar esos nuevos operadores lógicos en las herramientas software actuales con el fin de extender su funcionamiento no sólo aplicado a todo un conjunto de señales sino también a un espacio de tiempo en particular que se encuentre dentro de nuestro conjunto principal. 
\item Y por último, proporcionar una interfaz de usuario amigable que facilite la interacción con dichas herramientas, para este apartado  proponemos un espacio donde el usuario tenga que simplemente adjuntar los fichero de datos y operaciones (o elegir la operación a realizar desde las opciones disponibles) para finalmente poder visualizar y descargar la salida de señales en forma gráfica. 
\end{itemize}

\section{Organización}

<<<<<<< HEAD
Documento

El documento está dividido en X capítulos. En el capítulo \ref{cha:stl} detallaremos la semántica e implementación de los nuevos operadores lógicos. El capítulo \ref{cha:gui} está dedicado a la nueva interfaz gráfica de usuario. Continuamos con las conclusiones más relevantes del proyecto en el capítulo \ref{cha:concl}. Finalmente $\ldots$.

Equipo de trabajo 

Este proyecto ha sido realizado por dos estudiantes, Dymtro ap1 ap2 y Javier ap1 ap2, acompañados del tutor Jose Ignacio Requeno. Se empezó a realizar el X de septiembre del 2021 y constó de 3 fases: 

Primera 

	En esta fase se inició la investigación del proyecto, nos dedicamos a leer información sobre qué es la lógica temporal y la diferencia entre lógica modal, recurrimos tanto al material proporcionado por el instructor como a material externo y aprendimos un poco de su sintáxis. Esta fué la parte más complicada de todo el trabajo no sólo por la poca información que éxiste de este tema en la red, obligándonos a hacer búsquedas más exhaustivas y profundas sobre los datos que teníamos sino también por el cambio de perspectiva que tuvimos que realizar para comprender el concepto principal de ésta lógica que es que: Una afirmación se puede convertir en negación dependiendo del tiempo en el que se evalúa la expresión. 
	
Segunda

Despúes del proceso de cambio

Tercera

Planificación 
=======
El documento está dividido en X capítulos. En el capítulo \ref{cha:stl} detallaremos la semántica e implementación de los nuevos operadores lógicos. El capítulo \ref{cha:gui} está dedicado a la nueva interfaz gráfica de usuario. Continuamos con las conclusiones más relevantes del proyecto en el capítulo \ref{cha:concl}. Finalmente $\ldots$.

\chapter{Organización y tecnologías}
\section{Planificación y esfuerzo del proyecto}
El proyecto ha durado tantas semanas. Pepito ha trabajado en la tarea 1 y 2, Menganito ...
Hemos desarrollado 2 módulos nuevos de código, tantas líneas de código fuentes.

\section{Tecnologías}
En este proyecto extendemos o mejoramos las siguientes herramientas ya pre-existentes:
\begin{itemize}
	\item STLEval \cite{•}: Es una herramienta capaz de generar monitores a partir de especificaciones en STL. 
	\item ParetoLib \cite{•}: Es una librería de aprendizaje, que permite descubrir configuraciones (in)válidas de fórmulas STL a partir de plantillas paramétricas.
\end{itemize}

La interfaz gráfica, que es completamente novedosa, está montada sobre STLEval y ParetoLib y permite interactuar con ambas herramientas.
Los nuevos operadores operadores de STL descritos en \ref{cha:stl} están implementados sobre STLEval. 
La librería de aprendizaje ParetoLib utiliza internamente una distribución precompilada de STLEval.
Los binarios de STLEval en ParetoLib han sido actualizados para exportar las nuevas funcionalidades y permitir minar fórmulas STL paramétricas con los operadores introducidos en este trabajo.
La sección \ref{sec:estructura} ilustra gráficamente las dependencias entre paquetes, qué componentes han sido creados desde cero, y cuales han sido parcialmente actualizados.


>>>>>>> dc812837789c87e31e28b5d54c0ad180231424a5
